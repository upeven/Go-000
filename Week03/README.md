---
title: README
created: '2020-12-09T13:18:31.225Z'
modified: '2020-12-09T13:27:40.764Z'
---

# README
## week3学习总结

Go内存模型阐明了一个Go程序对某个变量的写入，如何才能确保被另一个读取该变量的Go协程监测到，即对一个变量来说，一个goroutine总是读取到最新的值。

1、一般使用sync来保证一致性。
2、也可以使用sync/atomic来保证，后者保证了操作的原子性。
3、通过channel来保证。

##### 事件的发生次序

在单个Go程中，读取和写入的表现必须与程序指定的执行顺序相一致。换言之， 仅在不会改变语言规范对Go程行为的定义时，编译器和处理器才会对读取和写入的执行重新排序。 由于存在重新排序，一个Go程监测到的执行顺序可能与另一个Go程监到的不同。例如，若一个Go程执行 a = 1; b = 2;，另一个Go程可能监测到 b 的值先于 a 更新。为了详细论述读取和写入的必要条件，我们定义了事件发生顺序，它表示Go程序中内存操作执行的 偏序关系。 若事件 e1 发生在 e2 之前， 那么我们就说 e2 发生在 e1 之后。 换言之，若 e1 既未发生在 e2 之前， 又未发生在 e2 之后，那么我们就说 e1 与 e2 是并发的。 

在单一Go程中，事件发生的顺序即为程序所表达的顺序。 

 若以下条件均成立，则对变量 v 的读取操作 r 就允许对 v 的写入操作 w 进行监测：

    r 不发生在 w 之前。
    在 w 之后 r 之前，不存在其它对 v 进行的写入操作 w'。

 为确保对变量 v 的读取操作 r 能够监测到特定的对 v 进行写入的操作 w，需确保 w 是唯一允许被 r 监测的写入操作。也就是说，若以下条件均成立，则 r 能保证监测到 w：

    w 发生在 r 之前。
    对共享变量 v 的其它任何写入操作都只能发生在 w 之前或 r 之后。


在单个Go程中并不存在并发，因此这两条定义是等价的：读取操作 r 可监测最近的写入操作 w 对 v 写入的值。当多个Go程访问共享变量 v 时，它们必须通过同步事件来建立发生顺序的条件，以此确保读取操作能监测到预期的写入。 

对大于单个机器字的值进行读取和写入，其表现如同以不确定的顺序对多个机器字大小的值进行操作。 

